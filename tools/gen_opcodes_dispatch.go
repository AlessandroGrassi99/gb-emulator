//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"os"
	"sort"
	"strings"
	"unicode"
)

// rawInstr mirrors the JSON structure in data/opcodes.json
type rawInstr struct {
	Mnemonic string `json:"mnemonic"`
	Operands []struct {
		Name      string `json:"name"`
		Immediate bool   `json:"immediate"`
		Increment bool   `json:"increment,omitempty"`
		Decrement bool   `json:"decrement,omitempty"`
	} `json:"operands"`
}

// jsonInstructions holds unprefixed and CB-prefixed instruction sets.
type jsonInstructions struct {
	Unprefixed map[string]rawInstr `json:"unprefixed"`
	Cbprefixed map[string]rawInstr `json:"cbprefixed"`
}

type DispatchEntry struct {
	FuncName            string // the generated Go‚Äêidentifier
	HumanRepresentation string
}

func main() {
	js, err := loadInstructions("data/opcodes.json")
	if err != nil {
		log.Fatalf("Error loading instructions: %v", err)
	}

	dispatchEntry := buildDispatchMap(js)

	if err := writeDispatchMap("opcodes_dispatch_gen.go", dispatchEntry); err != nil {
		log.Fatalf("Error writing opcodes_dispatch_gen.go: %v", err)
	}

	fmt.Println("Successfully generated opcodes_dispatch_gen.go")
}

// loadInstructions reads and parses the JSON instructions file.
func loadInstructions(path string) (*jsonInstructions, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("read file: %w", err)
	}
	var js jsonInstructions
	if err := json.Unmarshal(data, &js); err != nil {
		return nil, fmt.Errorf("parse json: %w", err)
	}
	return &js, nil
}

// buildDispatchMap processes raw and CB-prefixed opcodes into a map of exec function keys.
func buildDispatchMap(js *jsonInstructions) map[int]DispatchEntry {
	dispatchEntries := make(map[int]DispatchEntry, 512)

	processOpcodes(js.Unprefixed, "Op", 0, dispatchEntries)
	processOpcodes(js.Cbprefixed, "OpCb", 256, dispatchEntries)

	return dispatchEntries
}

// processOpcodes iterates a set of opcodes, generating keys and populating dispatchMap.
func processOpcodes(set map[string]rawInstr, prefix string, offset int, dispatchMap map[int]DispatchEntry) {
	for hexKey, instr := range set {
		var idxRaw int
		if _, err := fmt.Sscanf(hexKey, "0x%X", &idxRaw); err != nil {
			log.Fatalf("Invalid hex key %q: %v", hexKey, err)
		}
		idx := offset + idxRaw

		if instr.Mnemonic == "" || strings.HasPrefix(instr.Mnemonic, "ILLEGAL") {
			continue
		}

		funcName := prefix + goifyMnemonic(instr.Mnemonic)
		for _, op := range instr.Operands {
			if !op.Immediate {
				funcName += "Mem"
			}
			opName := goifyOperand(op.Name)
			funcName += opName
			if op.Increment {
				funcName += "Inc"
			}
			if op.Decrement {
				funcName += "Dec"
			}
		}

		entry := DispatchEntry{
			FuncName:            funcName,
			HumanRepresentation: instr.String(),
		}
		dispatchMap[idx] = entry
	}
}

// writeDispatchMap generates the Go source mapping opcodes to exec functions.
func writeDispatchMap(path string, dispatchMap map[int]DispatchEntry) error {
	var buf bytes.Buffer

	fmt.Fprintln(&buf, "// Code generated by tools/gen_opcodes_dispatch.go; DO NOT EDIT.")
	fmt.Fprintln(&buf, "package main")
	fmt.Fprintln(&buf)
	fmt.Fprintln(&buf, "var opcodeFuncs = map[uint16]func(*CPU,*Instruction)int{")

	indices := make([]int, 0, len(dispatchMap))
	for i := range dispatchMap {
		indices = append(indices, i)
	}
	sort.Ints(indices)

	for _, i := range indices {
		entry := dispatchMap[i]
		if entry.FuncName == "" {
			continue
		}
		desc := entry.HumanRepresentation // formerly "instrStr"
		if i < 256 {
			fmt.Fprintf(&buf, "\t0x%02X: %s,  // %s\n", i, entry.FuncName, desc)
		} else {
			fmt.Fprintf(&buf, "\t%d /* CB 0x%02X */: %s,  // %s\n",
				i, i-256, entry.FuncName, desc)
		}
	}

	fmt.Fprintln(&buf, "}")

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("go/format error: %w\nunformatted source:\n%s", err, buf.String())
	}

	return os.WriteFile(path, src, 0644)
}

// goifyMnemonic converts "LD" to "Ld", etc.
func goifyMnemonic(mn string) string {
	if mn == "" {
		return ""
	}
	runes := []rune(strings.ToLower(mn))
	runes[0] = unicode.ToUpper(runes[0])
	return string(runes)
}

// goifyOperand normalizes operand names like BC, n16, $00.
func goifyOperand(name string) string {
	s := strings.ToLower(name)
	switch s {
	case "n8", "n16", "a8", "a16", "e8":
		return strings.ToUpper(s)
	case "$00", "$08", "$10", "$18", "$20", "$28", "$30", "$38":
		return "RST" + strings.ToUpper(strings.TrimPrefix(name, "$"))
	}
	// Uppercase registers by default
	r := []rune(name)
	for i := range r {
		r[i] = unicode.ToUpper(r[i])
	}
	return string(r)
}

// A human-readable representation of the instruction
func (i *rawInstr) String() string {
	if i.Mnemonic == "" {
		return "UNKNOWN"
	}
	if len(i.Operands) == 0 {
		return i.Mnemonic
	}

	operands := make([]string, len(i.Operands))
	for idx, operand := range i.Operands {
		operandStr := operand.Name
		if operand.Increment {
			operandStr = operandStr + "++"
		}
		if operand.Decrement {
			operandStr = operandStr + "--"
		}
		if !operand.Immediate {
			operandStr = "(" + operandStr + ")"
		}

		operands[idx] = operandStr
	}
	operandsStr := strings.Join(operands, ", ")

	return fmt.Sprintf("%s %s", i.Mnemonic, operandsStr)
}
