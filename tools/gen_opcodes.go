//go:build ignore
// +build ignore

package main

import (
	_ "embed"
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strings"
)

// rawInstr represents the structure directly parsed from the JSON opcode definitions.
// It serves as an intermediate representation before creating the final Instruction struct literal.
type rawInstr struct {
	Opcode     string            `json:"opcode"` // Note: This field from JSON isn't directly used; we use the map key.
	Mnemonic   string            `json:"mnemonic"`
	Bytes      uint8             `json:"bytes"`
	Cycles     []int             `json:"cycles"`
	CbPrefixed bool              `json:"cbprefixed"` // Note: This is determined by which map (unprefixed/cbprefixed) the entry is in.
	Operands   []rawOp           `json:"operands"`
	Immediate  bool              `json:"immediate"`
	Flags      map[string]string `json:"flags"`
}

// rawOp represents the operand structure parsed from JSON.
type rawOp struct {
	Name      string `json:"name"`
	Bytes     uint8  `json:"bytes,omitempty"`
	Immediate bool   `json:"immediate"`
	Increment bool   `json:"increment,omitempty"`
	Decrement bool   `json:"decrement,omitempty"`
}

// jsonInstructions holds the structure of the entire opcodes.json file.
type jsonInstructions struct {
	Unprefixed map[string]rawInstr `json:"unprefixed"`
	Cbprefixed map[string]rawInstr `json:"cbprefixed"`
}

func main() {
	data, err := os.ReadFile("data/opcodes.json")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading opcodes.json: %v\n", err)
		os.Exit(1)
	}

	var js jsonInstructions
	if err := json.Unmarshal(data, &js); err != nil {
		fmt.Fprintf(os.Stderr, "Error unmarshalling opcodes.json: %v\n", err)
		os.Exit(1)
	}

	// Create the output file
	f, err := os.Create("opcodes_gen.go")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating opcodes_gen.go: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	// Write header
	fmt.Fprintln(f, "// Code generated by gen_opcodes.go; DO NOT EDIT.")
	fmt.Fprintln(f, "package main")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "//nolint:lll // Keeping lines long for generated code clarity")
	fmt.Fprintln(f, "var opcodes = Instructions{")

	// Iterate through all 512 possible opcode slots (0-255 for unprefixed, 256-511 for CB-prefixed)
	for i := range 512 {
		var entry *rawInstr
		var actualOpcodeValue int
		isCbPrefixed := false
		hexKey := "" // Will store the "0xXX" representation

		if i < 256 {
			// Unprefixed Opcodes
			actualOpcodeValue = i
			hexKey = fmt.Sprintf("0x%02X", actualOpcodeValue)
			if ri, ok := js.Unprefixed[hexKey]; ok {
				entry = &ri
			}
		} else {
			// CB-Prefixed Opcodes
			isCbPrefixed = true
			actualOpcodeValue = i - 256
			hexKey = fmt.Sprintf("0x%02X", actualOpcodeValue)
			if ri, ok := js.Cbprefixed[hexKey]; ok {
				entry = &ri
				entry.CbPrefixed = true // Ensure CbPrefixed is set correctly based on map source
			}
		}

		// If no instruction defined for this opcode, write an empty struct literal
		if entry == nil {
			// Use index comment for clarity on empty slots
			fmt.Fprintf(f, "\t{}, // Index %d (Opcode: %s, CB: %v)\n", i, hexKey, isCbPrefixed)
			continue
		}

		// --- Format Cycles ---
		cycleStrs := make([]string, len(entry.Cycles))
		for j, c := range entry.Cycles {
			cycleStrs[j] = fmt.Sprintf("%d", c)
		}
		cyclesLiteral := "[]int{" + strings.Join(cycleStrs, ", ") + "}"
		if len(entry.Cycles) == 0 {
			cyclesLiteral = "nil" // Use nil for empty slices
		}

		// --- Format Operands ---
		operandStrings := make([]string, len(entry.Operands))
		for j, op := range entry.Operands {
			parts := []string{
				fmt.Sprintf(`Name: %q`, op.Name),
			}
			// Only include non-default values for clarity
			if op.Bytes > 0 { // Check > 0 as Bytes is uint8
				parts = append(parts, fmt.Sprintf("Bytes: %d", op.Bytes))
			}
			if op.Immediate {
				parts = append(parts, "Immediate: true")
			}
			if op.Increment {
				parts = append(parts, "Increment: true")
			}
			if op.Decrement {
				parts = append(parts, "Decrement: true")
			}
			// Sort parts for consistent output order
			sort.Strings(parts[1:]) // Sort all but Name
			operandStrings[j] = "Operand{" + strings.Join(parts, ", ") + "}"
		}
		operandsLiteral := "[]Operand{" + strings.Join(operandStrings, ", ") + "}"
		if len(entry.Operands) == 0 {
			operandsLiteral = "nil" // Use nil for empty slices
		}

		// --- Format Flags ---
		flagStrings := make([]string, 0, len(entry.Flags))
		// Sort keys for deterministic output
		flagKeys := make([]string, 0, len(entry.Flags))
		for k := range entry.Flags {
			flagKeys = append(flagKeys, k)
		}
		sort.Strings(flagKeys)
		for _, k := range flagKeys {
			v := entry.Flags[k]
			flagStrings = append(flagStrings, fmt.Sprintf("%q: %q", k, v))
		}
		flagsLiteral := "map[string]string{" + strings.Join(flagStrings, ", ") + "}"
		if len(entry.Flags) == 0 {
			flagsLiteral = "nil" // Use nil for empty maps
		}

		// --- Emit the Go struct literal for Instruction ---
		// Corresponds to the fields in `ins.go:Instruction`
		fmt.Fprintf(f,
			"\t{Opcode: %q, Mnemonic: %q, Bytes: %d, Cycles: %s, CbPrefixed: %v, Operands: %s, Immediate: %v, Flags: %s},\n",
			hexKey,          // Opcode (string representation)
			entry.Mnemonic,  // Mnemonic
			entry.Bytes,     // Bytes
			cyclesLiteral,   // Cycles ([]int literal or nil)
			isCbPrefixed,    // CbPrefixed (bool) - derived from loop index
			operandsLiteral, // Operands ([]Operand literal or nil)
			entry.Immediate, // Immediate (bool)
			flagsLiteral,    // Flags (map[string]string literal or nil)
			// Note: The Execute field is intentionally omitted as it's assigned elsewhere (likely via a map lookup at runtime).
		)
	}

	// Closing brace for the Instructions array
	fmt.Fprintln(f, "}")

	fmt.Println("Successfully generated opcodes_gen.go")
}
